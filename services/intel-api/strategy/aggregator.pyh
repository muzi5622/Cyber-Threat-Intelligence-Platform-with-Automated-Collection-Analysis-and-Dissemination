from __future__ import annotations

from datetime import datetime, timedelta, timezone
from typing import Dict, Any, List, Tuple
from collections import Counter, defaultdict
import yaml

from .opencti_client import OpenCTIClient
from .scoring import compute_risk_score, decision_label


# -------------------------------------------------------------------
# Prevent strategy reports from summarizing themselves
# -------------------------------------------------------------------
EXCLUDE_REPORT_PREFIXES = (
    "Executive Daily Cyber Brief —",
    "Executive Weekly Cyber Risk Brief —",
    "Executive Cyber Risk Assessment —",
    "Monthly Threat Landscape & Trends —",
    "Daily Executive Summary —",
    "Weekly Threat Brief —",
)

THEME_KEYWORDS: List[str] = [
    "ransomware", "phishing", "credential", "exploit", "zero-day", "c2",
    "botnet", "malware", "apt", "supply chain", "ddos",
]

THEME_INTERPRETATION: Dict[str, str] = {
    "exploit": "Accelerated exploitation of exposed services suggests attackers are prioritizing speed-to-access over bespoke tooling.",
    "zero-day": "Zero-day themes imply elevated uncertainty and higher potential impact due to limited mitigations early in the window.",
    "credential": "Credential-focused activity is a leading indicator for account takeover and lateral movement risk.",
    "phishing": "Phishing volume indicates identity systems and user workflows remain high-leverage attack paths.",
    "ransomware": "Ransomware signals imply disruptive intent and high business impact (availability/operations).",
    "apt": "APT themes suggest long-horizon activity and potential strategic targeting rather than opportunistic noise.",
    "supply chain": "Supply-chain themes imply indirect compromise paths with amplified blast radius across vendors and dependencies.",
    "c2": "C2 signals suggest sustained footholds and the need to validate egress controls and detection coverage.",
    "ddos": "DDoS activity tends to correlate with disruption intent and reputational impact, especially for online services.",
    "malware": "Malware volume usually indicates broad commodity activity; the risk depends on delivery vectors and controls maturity.",
    "botnet": "Botnet activity indicates scalable infrastructure abuse and opportunistic targeting of exposed services.",
}

THEME_TO_EXPOSURE: Dict[str, str] = {
    "phishing": "Identity & Access (email/user workflows)",
    "credential": "Identity & Access (accounts/privilege)",
    "exploit": "Internet-facing infrastructure (patching/WAF/IPS)",
    "zero-day": "Internet-facing infrastructure (rapid mitigation)",
    "ransomware": "Backup/Recovery & endpoint resilience",
    "apt": "Long-horizon intrusion risk (monitoring/hunting)",
    "supply chain": "Third-party & software supply chain",
    "c2": "Network egress controls & detection",
    "ddos": "Availability & online service resilience",
    "malware": "Endpoint controls & delivery vectors",
    "botnet": "Perimeter exposure & service hardening",
}


# -------------------------------------------------------------------
# Helpers
# -------------------------------------------------------------------
def load_cfg(cfg_path: str) -> Dict[str, Any]:
    with open(cfg_path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {}


def iso(dt: datetime) -> str:
    return dt.astimezone(timezone.utc).isoformat().replace("+00:00", "Z")


def theme_counts(texts: List[str]) -> Counter:
    c = Counter()
    for t in texts:
        lt = (t or "").lower()
        for k in THEME_KEYWORDS:
            if k in lt:
                c[k] += 1
    return c


def theme_trends(curr: Counter, prev: Counter, top_n: int = 6) -> Dict[str, List[Tuple[str, int]]]:
    keys = set(curr.keys()) | set(prev.keys())
    deltas = [(k, int(curr.get(k, 0) - prev.get(k, 0))) for k in keys]
    rising = sorted([x for x in deltas if x[1] > 0], key=lambda x: x[1], reverse=True)[:top_n]
    falling = sorted([x for x in deltas if x[1] < 0], key=lambda x: x[1])[:top_n]
    return {"rising": rising, "falling": falling}


def strategic_driver_bullets(top_themes: List[Tuple[str, int]], max_bullets: int = 4) -> List[str]:
    bullets: List[str] = []
    for theme, _cnt in top_themes:
        msg = THEME_INTERPRETATION.get(theme)
        if msg and msg not in bullets:
            bullets.append(msg)
        if len(bullets) >= max_bullets:
            break
    if not bullets:
        bullets.append("No single theme dominated the period; maintain baseline monitoring and core hygiene controls.")
    return bullets


def leadership_actions_from_themes(top_themes: List[Tuple[str, int]]) -> List[str]:
    themes = {k for k, _ in top_themes}
    actions: List[str] = []
    if "phishing" in themes or "credential" in themes:
        actions.append("Approve a focused identity hardening push: tighten DMARC, review MFA coverage for privileged roles, and expand conditional access policies.")
    if "exploit" in themes or "zero-day" in themes:
        actions.append("Authorize an emergency patch/mitigation playbook for internet-facing assets (patch SLAs, WAF/IPS virtual patching, exposure inventory).")
    if "ransomware" in themes:
        actions.append("Sponsor a ransomware readiness review: validate restore SLAs, test backups, and confirm endpoint protection coverage on critical systems.")
    if "supply chain" in themes:
        actions.append("Direct vendor risk review for key software/providers and prioritize SBOM/third-party patch visibility where possible.")
    if "ddos" in themes:
        actions.append("Validate DDoS resilience and run an availability tabletop exercise for critical online services.")
    if not actions:
        actions.append("Maintain baseline security hygiene and monitoring; no urgent strategic action triggered by this period’s themes.")
    return actions[:5]


def exposure_summary(counts: Counter, top_n: int = 4) -> List[Tuple[str, int]]:
    exp_counts: Dict[str, int] = defaultdict(int)
    for theme, cnt in counts.items():
        exp = THEME_TO_EXPOSURE.get(theme)
        if exp:
            exp_counts[exp] += int(cnt)
    return sorted(exp_counts.items(), key=lambda x: x[1], reverse=True)[:top_n]


def fmt_prev(n: int) -> str:
    return str(n) if n > 0 else "N/A (baseline building)"


def render_trend_block(trends: Dict[str, List[Tuple[str, int]]]) -> List[str]:
    out: List[str] = []
    rising = trends.get("rising", [])
    falling = trends.get("falling", [])

    if rising:
        out.append("**Rising signals:**")
        for k, d in rising:
            out.append(f"- {k}: +{d}")
    else:
        out.append("- No rising signals vs previous period.")

    if falling:
        out.append("\n**Falling signals:**")
        for k, d in falling:
            out.append(f"- {k}: {d}")

    return out


# -------------------------------------------------------------------
# DAILY (exec)
# -------------------------------------------------------------------
def build_daily_exec_summary(cfg_path: str) -> Dict[str, Any]:
    cfg = load_cfg(cfg_path)
    org = cfg.get("org_profile", {})
    client = OpenCTIClient()

    now = datetime.now(timezone.utc)
    start = now - timedelta(days=1)
    prev_start = start - timedelta(days=1)

    curr = client.list_reports(
        iso(start), iso(now),
        first=700,
        exclude_name_prefixes=list(EXCLUDE_REPORT_PREFIXES),
    )
    prev = client.list_reports(
        iso(prev_start), iso(start),
        first=700,
        exclude_name_prefixes=list(EXCLUDE_REPORT_PREFIXES),
    )

    curr_edges = curr.get("reports", {}).get("edges", [])
    prev_edges = prev.get("reports", {}).get("edges", [])

    items: List[Dict[str, Any]] = []
    curr_texts: List[str] = []
    prev_texts: List[str] = []

    for e in curr_edges:
        n = e["node"]
        s = compute_risk_score(n, org, cfg)
        items.append({
            "id": n["id"],
            "name": n.get("name") or "Report",
            "risk": s["risk"],
            "decision": decision_label(s["risk"], cfg),
        })
        curr_texts.append((n.get("name") or "") + "\n" + (n.get("description") or ""))

    for e in prev_edges:
        n = e["node"]
        prev_texts.append((n.get("name") or "") + "\n" + (n.get("description") or ""))

    items.sort(key=lambda x: x["risk"], reverse=True)
    top_items = items[:5]

    curr_counts = theme_counts(curr_texts)
    prev_counts = theme_counts(prev_texts)
    deltas = theme_trends(curr_counts, prev_counts, top_n=3)

    avg_risk = sum([x["risk"] for x in items]) / max(1, len(items))
    posture = "ELEVATED" if avg_risk >= 70 else ("ATTENTION" if avg_risk >= 55 else "BASELINE")

    primary = [k for k, _ in curr_counts.most_common(3)]
    top_themes = curr_counts.most_common(6)

    # OFF unless explicitly enabled later
    include_annex = str(cfg.get("exec_brief", {}).get("include_soc_annex", "false")).lower() == "true"

    body: List[str] = []
    body.append(f"# Executive Daily Cyber Brief — {now.strftime('%Y-%m-%d')} ({org.get('name','Demo Org')})")
    body.append("**Window:** last 24 hours (UTC)\n")

    body.append("## Executive Snapshot")
    body.append(f"- **Risk posture:** **{posture}** (Avg risk {avg_risk:.0f}/100)")
    body.append(f"- **Intel volume:** {len(curr_edges)} reports (prev {fmt_prev(len(prev_edges))})")
    if primary:
        body.append(f"- **Primary drivers:** {', '.join(primary)}")
    body.append("")

    body.append("## What changed (vs yesterday)")
    if deltas["rising"]:
        for k, d in deltas["rising"]:
            body.append(f"- **Rising signal:** {k} (+{d})")
    else:
        body.append("- No meaningful increase in dominant themes vs yesterday.")
    if deltas["falling"]:
        for k, d in deltas["falling"]:
            body.append(f"- **Falling signal:** {k} ({d})")
    body.append("")

    body.append("## Key Decisions (Top 5)")
    if not top_items:
        body.append("- No report signals detected in the last 24h.")
    else:
        for t in top_items:
            body.append(f"- **[{t['decision']}]** (Risk {t['risk']}/100) — {t['name']}")
    body.append("")

    body.append("## Leadership Actions (Next 72 hours)")
    for a in leadership_actions_from_themes(top_themes):
        body.append(f"- {a}")

    if include_annex:
        obs = client.list_observables(iso(start), iso(now), first=200).get("stixCyberObservables", {}).get("edges", [])
        obs_nodes = [o["node"] for o in obs]
        obs_nodes.sort(key=lambda x: (x.get("x_opencti_score") or 0), reverse=True)

        body.append("\n## Technical Annex (SOC)")
        body.append(f"- Observables created: {len(obs_nodes)}")
        if obs_nodes[:5]:
            body.append("\n**Top observables:**")
            for o in obs_nodes[:5]:
                body.append(f"- {o.get('entity_type','Observable')} (Score {o.get('x_opencti_score',0)}) — `{o.get('observable_value','')}`")

    return {
        "report_name": f"Executive Daily Cyber Brief — {now.strftime('%Y-%m-%d')}",
        "description": "\n".join(body),
        "top_items": top_items,
    }


# -------------------------------------------------------------------
# WEEKLY (exec)
# -------------------------------------------------------------------
def build_weekly_brief(cfg_path: str) -> Dict[str, Any]:
    cfg = load_cfg(cfg_path)
    org = cfg.get("org_profile", {})
    client = OpenCTIClient()

    now = datetime.now(timezone.utc)
    start = now - timedelta(days=7)
    prev_start = start - timedelta(days=7)

    curr = client.list_reports(
        iso(start), iso(now),
        first=1500,
        exclude_name_prefixes=list(EXCLUDE_REPORT_PREFIXES),
    )
    prev = client.list_reports(
        iso(prev_start), iso(start),
        first=1500,
        exclude_name_prefixes=list(EXCLUDE_REPORT_PREFIXES),
    )

    curr_edges = curr.get("reports", {}).get("edges", [])
    prev_edges = prev.get("reports", {}).get("edges", [])

    curr_texts = [((e["node"].get("name") or "") + "\n" + (e["node"].get("description") or "")) for e in curr_edges]
    prev_texts = [((e["node"].get("name") or "") + "\n" + (e["node"].get("description") or "")) for e in prev_edges]

    curr_counts = theme_counts(curr_texts)
    prev_counts = theme_counts(prev_texts)
    trends = theme_trends(curr_counts, prev_counts, top_n=5)

    top_themes = curr_counts.most_common(7)
    exposures = exposure_summary(curr_counts, top_n=4)

    scored = []
    for e in curr_edges:
        n = e["node"]
        s = compute_risk_score(n, org, cfg)
        scored.append({"id": n["id"], "name": n.get("name") or "Report", "risk": s["risk"], "decision": decision_label(s["risk"], cfg)})
    scored.sort(key=lambda x: x["risk"], reverse=True)

    body: List[str] = []
    body.append(f"# Executive Weekly Cyber Risk Brief — Week ending {now.strftime('%Y-%m-%d')} ({org.get('name','Demo Org')})")
    body.append("**Window:** last 7 days (UTC)\n")

    body.append("## Executive Snapshot")
    body.append(f"- **Intel volume:** {len(curr_edges)} reports (prev {fmt_prev(len(prev_edges))})")
    if top_themes:
        body.append(f"- **Primary drivers:** {', '.join([k for k, _ in top_themes[:3]])}")
    body.append("")

    body.append("## Strategic Drivers")
    for b in strategic_driver_bullets(top_themes, max_bullets=4):
        body.append(f"- {b}")
    body.append("")

    body.append("## Business Exposure Assessment")
    if exposures:
        for exp, v in exposures:
            body.append(f"- **{exp}** — signal strength {v}")
    else:
        body.append("- No dominant exposure areas detected.")
    body.append("")

    body.append("## Trend Signals (Week-over-Week)")
    body.extend(render_trend_block(trends))
    body.append("")

    body.append("## Top Strategic Risks (Top 8)")
    for x in scored[:8]:
        body.append(f"- **[{x['decision']}]** {x['name']} ({x['risk']}/100)")
    body.append("")

    body.append("## Leadership Actions")
    for a in leadership_actions_from_themes(top_themes):
        body.append(f"- {a}")

    return {
        "report_name": f"Executive Weekly Cyber Risk Brief — Week ending {now.strftime('%Y-%m-%d')}",
        "description": "\n".join(body),
        "top_items": scored[:10],
    }


# -------------------------------------------------------------------
# MONTHLY (board-style)
# -------------------------------------------------------------------
def build_monthly_landscape(cfg_path: str, days: int = 30) -> Dict[str, Any]:
    cfg = load_cfg(cfg_path)
    org = cfg.get("org_profile", {})
    client = OpenCTIClient()

    now = datetime.now(timezone.utc)
    start = now - timedelta(days=days)
    prev_start = start - timedelta(days=days)

    curr = client.list_reports(
        iso(start), iso(now),
        first=3000,
        exclude_name_prefixes=list(EXCLUDE_REPORT_PREFIXES),
    )
    prev = client.list_reports(
        iso(prev_start), iso(start),
        first=3000,
        exclude_name_prefixes=list(EXCLUDE_REPORT_PREFIXES),
    )

    curr_edges = curr.get("reports", {}).get("edges", [])
    prev_edges = prev.get("reports", {}).get("edges", [])

    curr_texts = [((e["node"].get("name") or "") + "\n" + (e["node"].get("description") or "")) for e in curr_edges]
    prev_texts = [((e["node"].get("name") or "") + "\n" + (e["node"].get("description") or "")) for e in prev_edges]

    curr_counts = theme_counts(curr_texts)
    prev_counts = theme_counts(prev_texts)
    trends = theme_trends(curr_counts, prev_counts, top_n=6)

    top_themes = curr_counts.most_common(8)
    exposures = exposure_summary(curr_counts, top_n=4)

    scored = []
    for e in curr_edges:
        n = e["node"]
        s = compute_risk_score(n, org, cfg)
        scored.append({"id": n["id"], "name": n.get("name") or "Report", "risk": s["risk"], "decision": decision_label(s["risk"], cfg)})
    scored.sort(key=lambda x: x["risk"], reverse=True)

    avg_risk = sum([x["risk"] for x in scored]) / max(1, len(scored))
    prev_text = "N/A (baseline building)"
    if prev_edges:
        prev_risks = [compute_risk_score(e["node"], org, cfg)["risk"] for e in prev_edges]
        prev_avg = (sum(prev_risks) / len(prev_risks)) if prev_risks else 0.0
        prev_text = f"{prev_avg:.0f}/100"

    primary = [k for k, _ in top_themes[:3]]
    narrative = f"Primary drivers were {', '.join(primary)}; overall risk averaged {avg_risk:.0f}/100 (prev {prev_text})."

    body: List[str] = []
    body.append(f"# Executive Cyber Risk Assessment — {now.strftime('%B %Y')} ({org.get('name','Demo Org')})")
    body.append(f"**Assessment window:** last {days} days (UTC)\n")

    body.append("## Executive Summary")
    body.append(f"- {narrative}")
    body.append(f"- **Intel volume:** {len(curr_edges)} reports (prev {fmt_prev(len(prev_edges))})")
    body.append("")

    body.append("## Strategic Drivers (Why this matters)")
    for b in strategic_driver_bullets(top_themes, max_bullets=4):
        body.append(f"- {b}")
    body.append("")

    body.append("## Business Exposure Assessment (Where you’re exposed)")
    if exposures:
        for exp, v in exposures:
            body.append(f"- **{exp}** — signal strength {v}")
    else:
        body.append("- No dominant exposure areas detected.")
    body.append("")

    body.append("## Trend Signals (Period-over-Period)")
    body.extend(render_trend_block(trends))
    body.append("")

    body.append("## Top Strategic Risks (Top 10)")
    for x in scored[:10]:
        body.append(f"- **[{x['decision']}]** {x['name']} ({x['risk']}/100)")
    body.append("")

    body.append("## Leadership Actions")
    for a in leadership_actions_from_themes(top_themes):
        body.append(f"- {a}")

    return {
        "report_name": f"Executive Cyber Risk Assessment — {now.strftime('%B %Y')}",
        "description": "\n".join(body),
        "top_items": scored[:10],
    }
 
